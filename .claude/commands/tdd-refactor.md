---
description: TDD Refactor 단계 - 리팩토링 주석 확인 및 개선 사항 제안 (코드 구현 X)
---

# TDD Refactor Phase

당신은 TDD의 Refactor 단계를 수행합니다. 테스트 코드의 리팩토링 관련 주석을 확인하고, 리팩토링의 타당성을 검증한 후, 추가 개선 사항을 제안합니다.

**중요: 이 단계에서는 코드를 직접 구현하지 않습니다. 분석과 제안만 수행합니다.**

## 작업 순서

### 1. 테스트 코드의 리팩토링 주석 확인
테스트 파일에서 리팩토링 관련 주석을 찾아 분석합니다:

```java
/**
 * 리팩토링 1) userPointTable은 외부 의존성이기 때문에 Mocking이 필요함
 * 문제) Mocking을 하려면 PointService는 userPointTable을 직접 의존하는 부분을 제거해야 함.
 * 해결) DI를 위해 userPointTable의 인터페이스를 생성, userPointTable에 implement
 */
```

**확인 항목:**
- 리팩토링 번호와 내용
- 문제 인식
- 해결 방안
- 적용 여부

### 2. 현재 구현 상태 분석
- 해당 리팩토링이 실제로 적용되었는지 확인
- 적용된 방식이 주석에 명시된 의도와 일치하는지 검증
- 관련 파일들 확인 (Service, Repository, Controller 등)

### 3. 리팩토링 타당성 검증 보고서 작성

```markdown
## 🔍 리팩토링 분석 보고서

### 📋 발견된 리팩토링 주석

#### 리팩토링 1: [제목]
**주석 내용:**
- 문제: [문제 설명]
- 해결: [해결 방안]

**현재 구현 상태:**
- ✅ 적용됨 / ❌ 미적용 / ⚠️ 부분 적용
- 적용 파일: [파일 목록]
- 적용 방식: [설명]

**타당성 평가:**
- ✅ 적절함: [이유]
- ⚠️ 개선 필요: [이유]
- ❌ 부적절함: [이유]

---

#### 리팩토링 2: [제목]
...
```

### 4. 추가 리팩토링 제안
현재 코드를 분석하여 추가로 개선할 수 있는 부분을 제안합니다.

**분석 기준:**
1. **SOLID 원칙**
   - Single Responsibility Principle
   - Open-Closed Principle
   - Liskov Substitution Principle
   - Interface Segregation Principle
   - Dependency Inversion Principle

2. **코드 품질**
   - 중복 코드 (DRY)
   - 복잡도 (Cyclomatic Complexity)
   - 네이밍 (명확성, 일관성)
   - 메서드 길이
   - 클래스 크기

3. **테스트 가능성**
   - Mock 사용 적절성
   - 테스트 독립성
   - 테스트 가독성

4. **설계 패턴**
   - 적절한 패턴 적용 여부
   - 과도한 추상화 여부

5. **예외 처리**
   - 일관된 예외 처리
   - 적절한 예외 타입
   - 예외 메시지 관리

**제안 형식:**

```markdown
## 💡 추가 리팩토링 제안

### 우선순위 High

#### 제안 1: [제목]
**현재 상태:**
```java
// 현재 코드 예시 (간략히)
```

**문제점:**
- [문제 1]
- [문제 2]

**개선 방향:**
```java
// 개선 후 구조 (의사코드)
```

**기대 효과:**
- [효과 1]
- [효과 2]

**적용 파일:**
- [파일명1]
- [파일명2]

---

### 우선순위 Medium

#### 제안 2: [제목]
...

---

### 우선순위 Low

#### 제안 3: [제목]
...
```

### 5. 리팩토링 체크리스트 제공

```markdown
## ✅ 리팩토링 체크리스트

### 필수 (Must Have)
- [ ] [항목 1]
- [ ] [항목 2]

### 권장 (Should Have)
- [ ] [항목 1]
- [ ] [항목 2]

### 선택 (Could Have)
- [ ] [항목 1]
- [ ] [항목 2]
```

### 6. 사용자 확인 및 선택
```markdown
## 🎯 다음 단계

위의 리팩토링 제안 중 적용하고 싶은 항목을 선택해주세요:
1. 모두 적용
2. 우선순위 High만 적용
3. 특정 항목 선택 적용
4. 리팩토링 건너뛰기

**선택하신 항목을 알려주시면, 구체적인 구현 가이드를 제공하겠습니다.**
```

## 분석 가이드

### ✅ 좋은 리팩토링 예시

**1. 의존성 역전 (DIP)**
```
현재: PointService → UserPointTable (구체 클래스)
개선: PointService → UserPointRepository (인터페이스) ← UserPointTable
효과: 테스트 용이성, 확장성 향상
```

**2. 중복 코드 제거**
```
현재: validateUserId() 로직이 여러 메서드에 중복
개선: 공통 검증 메서드로 추출
효과: 유지보수성 향상, 일관성 보장
```

**3. 예외 처리 통합**
```
현재: 하드코딩된 예외 메시지
개선: ErrorCode enum으로 중앙 관리
효과: 일관된 에러 응답, 관리 용이
```

### ⚠️ 주의해야 할 것

**1. 과도한 추상화**
```
❌ 나쁨: 테스트에 없는 기능을 위한 추상화
✅ 좋음: 현재 필요에 맞는 적절한 추상화
```

**2. 성급한 최적화**
```
❌ 나쁨: 성능 문제가 없는데 복잡한 최적화
✅ 좋음: 가독성과 유지보수성 우선
```

**3. 테스트 깨뜨리기**
```
❌ 나쁨: 리팩토링 후 테스트 실패
✅ 좋음: 모든 테스트 통과 유지
```

## 체크 포인트

리팩토링 제안 시 다음을 확인합니다:

1. **테스트 통과 유지**: 리팩토링 후에도 모든 테스트가 통과해야 함
2. **동작 변경 없음**: 외부에서 보이는 동작은 그대로
3. **가독성 향상**: 코드를 읽기 쉬워졌는가
4. **유지보수성**: 수정하기 쉬워졌는가
5. **확장성**: 새 기능 추가가 쉬워졌는가
6. **일관성**: 기존 패턴과 조화를 이루는가

## 참고 파일
- `src/test/java/**/*Test.java` - 리팩토링 주석 확인
- `src/main/java/**/PointService.java` - Service 구현
- `src/main/java/**/PointController.java` - Controller 구현
- `DEV_LOG.md` - 기존 리팩토링 히스토리
- `IMPLEMENTATION_PLAN.md` - 설계 원칙

## 출력 예시

```markdown
## 🔍 리팩토링 분석 보고서

### 📋 발견된 리팩토링 주석: 3개

#### 리팩토링 1: UserPointRepository 인터페이스 도입
**주석 내용:**
- 문제: userPointTable 직접 의존으로 Mocking 불가
- 해결: 인터페이스 생성 및 DI 적용

**현재 구현 상태:** ✅ 적용됨
- UserPointRepository.java 생성
- UserPointTable이 인터페이스 구현
- PointService가 인터페이스에 의존

**타당성 평가:** ✅ 적절함
- DIP 원칙 준수
- 테스트 용이성 확보
- 향후 구현체 교체 가능

---

## 💡 추가 리팩토링 제안

### 우선순위 High

#### 제안 1: Service 메서드에 @Transactional 적용 고려
**현재 상태:** 트랜잭션 관리 없음

**문제점:**
- 포인트 업데이트와 히스토리 저장이 원자적이지 않음
- 부분 실패 시 데이터 불일치 가능

**개선 방향:**
- @Transactional 어노테이션 적용
- 또는 in-memory 특성상 수동 롤백 로직 구현

**기대 효과:**
- 데이터 일관성 보장
- 에러 시 안전한 롤백

---

## ✅ 리팩토링 체크리스트

### 필수 (Must Have)
- [x] 의존성 역전 원칙 적용
- [x] ErrorCode enum 중앙 관리
- [ ] 트랜잭션 처리

### 권장 (Should Have)
- [ ] 공통 검증 로직 추출
- [ ] JavaDoc 업데이트

---

## 🎯 다음 단계

위의 리팩토링 제안을 검토해주세요.
적용하고 싶은 항목이 있으면 알려주시면 구체적인 구현 가이드를 제공하겠습니다.
```

## 주의사항

1. **코드를 직접 구현하지 않습니다** - 분석과 제안만
2. **테스트 주석을 수정하지 않습니다** - 읽기만
3. **기존 패턴을 존중합니다** - DEV_LOG.md 참고
4. **실용적인 제안**: 이론보다는 실제 적용 가능한 것
5. **우선순위 명확히**: High/Medium/Low로 구분
